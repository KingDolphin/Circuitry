import {IOObject} from "core/models/IOObject";
import {DigitalComponent} from "digital/models/index";
import {DigitalObjectSet} from "digital/utils/ComponentUtils";
import {OutputPort} from "digital/models/ports/OutputPort";
import {ANDGate} from "digital/models/ioobjects/gates/ANDGate";
import {ORGate} from "digital/models/ioobjects/gates/ORGate";
import {NOTGate} from "digital/models/ioobjects/gates/BUFGate";
import {XORGate} from "digital/models/ioobjects/gates/XORGate";
import {DigitalWire} from "digital/models/DigitalWire";


/* Notes for connecting components
    const designer = new DigitalCircuitDesigner(0);
    const a = new Switch(), b = new Switch(), o = new LED(), and_gate = new ANDGate();
    const w1 = new DigitalWire(a.getOutputPort(0), and_gate.getInputPort(0));
    const w2 = new DigitalWire(b.getOutputPort(0), and_gate.getInputPort(1));
    const w3 = new DigitalWire(and_gate.getOutputPort(0), o.getInputPort(0));

    a.getOutputPort(0).connect(w1);
    and_gate.getInputPort(0).connect(w1);

    b.getOutputPort(0).connect(w2);
    and_gate.getInputPort(1).connect(w2);

    and_gate.getOutputPort(0).connect(w3);
    o.getInputPort(0).connect(w3);

    let objectSet = new DigitalObjectSet([a, b, o, and_gate, w1, w2, w3]);
*/

interface ReturnValue {
    circuit: DigitalObjectSet;
    retIndex: number;
    recentPort: OutputPort;
}

function GenerateTokens(input: string): Array<string> | null {
    if(input == null) return null;
    const tokenList = new Array<string>();
    let buffer = "";
    let c: string;

    for(let i = 0; i < input.length; i++) {
        c = input[i];
        switch(c) {
        case " ":
            if(buffer.length > 0) {
                tokenList.push(buffer);
                buffer = "";
            }
            break;
        case "(":
        case ")":
        case "&":
        case "^":
        case "|":
        case "!":
            if(buffer.length > 0) {
                tokenList.push(buffer);
                buffer = "";
            }
            tokenList.push(c);
            break;
        default:
            buffer += c;
            break;
        }
    }

    if(buffer.length > 0) {
        tokenList.push(buffer);
    }

    return tokenList;
}

function Expr(tokens: Array<string>, index: number, inputs: Map<string, DigitalComponent>):
ReturnValue | null {
    return OrExpr(tokens, index, inputs);
}

function OrExpr(tokens: Array<string>, index: number, inputs: Map<string, DigitalComponent>):
ReturnValue | null {
    const leftRet = XorExpr(tokens, index, inputs);
    index = leftRet.retIndex;
    if(index >= tokens.length || tokens[index] != "^") {
        return leftRet;
    }
    index += 1;
    if(index >= tokens.length) {
        throw new Error("Missing Right Operand: |");
    }

    const leftCircuit = leftRet.circuit;
    const leftOutput = leftRet.recentPort;

    const rightRet = OrExpr(tokens, index, inputs);
    const rightCircuit = rightRet.circuit;
    index = rightRet.retIndex;
    const rightOutput = rightRet.recentPort;

    const orGate = new ORGate();
    const w1 = new DigitalWire(leftOutput, orGate.getInputPort(0));
    const w2 = new DigitalWire(rightOutput, orGate.getInputPort(1));
    leftOutput.connect(w1);
    orGate.getInputPort(0).connect(w1);
    rightOutput.connect(w2);
    orGate.getInputPort(1).connect(w2);
    const newOutput = orGate.getOutputPort(0);

    const newComponents: IOObject[] = [orGate, w1, w2];
    const newCircuit = new DigitalObjectSet(newComponents.concat(
        leftCircuit.toList()).concat(rightCircuit.toList()));

    return {circuit: newCircuit, retIndex: index, recentPort: newOutput};
}

function XorExpr(tokens: Array<string>, index: number, inputs: Map<string, DigitalComponent>):
ReturnValue | null {
    return null;
}

function AndExpr(tokens: Array<string>, index: number, inputs: Map<string, DigitalComponent>):
ReturnValue | null {
    return null;
}

function NotExpr(tokens: Array<string>, index: number, inputs: Map<string, DigitalComponent>):
ReturnValue | null {
    return null;
}

function ParenExpr(tokens: Array<string>, index: number, inputs: Map<string, DigitalComponent>):
ReturnValue | null {
    return null;
}


/**
 * Main driver function for parsing an expression into a circuit
 *
 * @param  inputs A map correlating input name to the DigitalComponent it represents
 * @param  expression The expression to be parsed
 * @param  output The DigitalComponent to use as an output, port 0 will be used
 * @return The circuit generated by the given expression, null on error (see above)
 * @throws {Error} if any of the input parameters are null or undefined
 * @throws {Error} if an input in inputs is has an input port or does not have an output port
 *                   (thus is not a "real" Input)
 * @throws {Error} if output has an output port or does not have an input port
 *                   (thus is not a "real" Output)
 * @throws {Error} if expression requests an input not found in inputs
 * @throws {Error} if there is an unmatched '(' or ')'
 * @throws {Error} if there is a '!', '&', '^', or '|' that is missing an operand
 */
export function ExpressionToCircuit(inputs: Map<string, DigitalComponent>,
                                    expression: string,
                                    output: DigitalComponent): DigitalObjectSet | null {
    if(inputs == null)  throw new Error("Null Parameter: inputs");
    if(expression == null) throw new Error("Null Parameter: expression");
    if(output == null) throw new Error("Null Parameter: output");

    for(const [name, component] of inputs) {
        if(component.getInputPortCount().getValue() != 0
          || component.getOutputPortCount().getValue() == 0) {
            throw new Error("Not An Input: " + name);
        }
    }

    if(output.getInputPortCount().getValue() == 0
      || output.getOutputPortCount().getValue() != 0) {
        throw new Error("Supplied Output Is Not An Output");
    }

    const tokenList = GenerateTokens(expression);
    let token: string;
    for(let i = 0; i < tokenList.length; i++) {
        token = tokenList[i];
        switch(token) {
        case "(":
        case ")":
        case "&":
        case "^":
        case "|":
        case "!":
            break;
        default:
            if(!inputs.has(token))
                throw new Error("Input Not Found: " + token);
            break;
        }
    }

    if(inputs.size == 0) {
        return new DigitalObjectSet();
    }

    return new DigitalObjectSet();
}